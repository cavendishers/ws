{% extends 'data_hall/base.html' %}
{% load static %}

{% block title %}{{ industry_name }}产业链图谱 - 中国新势力企业态势感知系统{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
<link rel="stylesheet" href="{% static 'data_hall/css/industry_chain.css' %}">
<link rel="stylesheet" href="{% static 'data_hall/css/chain-sidebar.css' %}">
{% endblock %}

{% block content %}
<div class="container mx-auto px-6 py-4">
    <!-- 产业链图谱 -->
    <section class="section-card" id="industry-chain-section">
        <h2 class="section-title">
            <i class="fas fa-project-diagram text-[var(--accent)]"></i>
            <span>{{ industry_name }}产业链图谱</span>
        </h2>

        <!-- 视图选项 -->
        <div class="chart-view-options">
            <button class="view-option active">框架图</button>
            <button class="view-option">树状图</button>
        </div>

        <!-- 图表区域 -->
        <div class="graph-main-content-wrapper mt-4">
            <div id="chart-zoom-pan-container">
                <div id="industry-chain-container" style="visibility: hidden;">
                    <!-- 图谱内容由JS动态生成 -->
                </div>
            </div> 

            <aside class="graph-sidebar-actions">
                <div class="graph-sidebar-icon-group">
                    <div class="graph-sidebar-item" title="指示器">
                        <svg class="gauge-svg-placeholder" viewBox="0 0 50 50" width="22" height="22" style="fill:currentColor">
                            <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-opacity="0.3" stroke-width="4"/>
                            <path d="M25 5 A20 20 0 0 1 43.3 16.7" fill="none" stroke="currentColor" stroke-width="4"/>
                            <circle cx="25" cy="25" r="3" fill="currentColor"/>
                            <line x1="25" y1="25" x2="43" y2="17" stroke="currentColor" stroke-width="2"/>
                        </svg>
                        <span>指示器</span>
                    </div>
                    <div class="graph-sidebar-item" title="刷新">
                        <i class="fas fa-sync-alt"></i>
                        <span>刷新</span>
                    </div>
                    <div class="graph-sidebar-item" title="全屏">
                        <i class="fas fa-expand-arrows-alt"></i>
                        <span>全屏</span>
                    </div>
                    <div class="graph-sidebar-item" title="去水印">
                        <i class="fas fa-tint-slash"></i>
                        <span>去水印</span>
                    </div>
                    <div class="graph-sidebar-item" title="下载">
                        <i class="fas fa-download"></i>
                        <span>下载</span>
                    </div>
                    <div class="graph-sidebar-item" title="保存">
                        <i class="fas fa-save"></i>
                        <span>保存</span>
                    </div>
                </div>
            </aside>
        </div>
    </section>
    
    <!-- 页脚信息 -->
    <footer class="graph-footer">
        以上数据基于公开信息分析挖掘的成果，仅供参考，不构成任何明示或暗示的观点或保证。
    </footer>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // 从后端获取产业链数据
    const graphData = JSON.parse('{{ chain_data|escapejs }}');
    document.addEventListener('DOMContentLoaded', function () {
    const container = document.getElementById('industry-chain-container');
    const zoomPanContainer = document.getElementById('chart-zoom-pan-container');

    if (!graphData || !graphData.Children) {
        console.error('graphData is not defined or has no Children property.');
        container.innerHTML = '<p style="color:red; text-align:center;">Error: Graph data not found.</p>';
        return;
    }
    
    renderGraph(graphData.Children, container);

    let scale = 1;
    let panning = false;
    let pointX = 0;
    let pointY = 0;
    let start = { x: 0, y: 0 };
    let translateX = 0;
    let translateY = 0;

    function setTransform() {
        container.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }
 
    // 自动适应视窗，展示全局视图
    function fitToViewport() {
        // 临时重置变换，以获取未缩放时的真实尺寸
        container.style.transform = 'translate(0px, 0px) scale(1)';
        
        // 获取容器原始尺寸
        const containerRect = container.getBoundingClientRect();
        const zoomContainerRect = zoomPanContainer.getBoundingClientRect();
        
        // 计算合适的缩放比例（稍微缩小一点，留出边距）
        const scaleX = (zoomContainerRect.width - 80) / containerRect.width;
        const scaleY = (zoomContainerRect.height - 80) / containerRect.height;
        scale = Math.min(scaleX, scaleY, 1); // 不要放大，只缩小
        
        // 确保最小缩放不会太小
        scale = Math.max(scale, 0.25);
        
        // 计算水平居中位置
        translateX = (zoomContainerRect.width - containerRect.width * scale) / 2;
        
        // 调整垂直位置 - 只留出少量顶部间隙而不是垂直居中
        const topMargin = 10; // 顶部固定间隙，可以根据需要调整
        translateY = topMargin;
        
        // 确保图表不会被底部裁剪
        const scaledHeight = containerRect.height * scale;
        if (topMargin + scaledHeight > zoomContainerRect.height) {
            // 如果高度超出视口，调整vertical scroll而不改变缩放
            translateY = Math.min(topMargin, zoomContainerRect.height - scaledHeight);
        }
        
        // 应用变换
        setTransform();
        
        // 变换完成后显示图表
        container.style.visibility = 'visible';
        
        console.log(`自动适应: 缩放比例=${scale.toFixed(2)}, 位置X=${translateX.toFixed(0)}px, Y=${translateY.toFixed(0)}px`);
    }
    
    // 页面加载时立即适应视窗，不使用延时
    fitToViewport();
    
    // 窗口大小改变时重新适应
    window.addEventListener('resize', fitToViewport);
    
    // 刷新按钮点击事件
    document.querySelector('.graph-sidebar-item[title="刷新"]').addEventListener('click', function() {
        // 直接刷新整个页面
        window.location.reload();
    });

    zoomPanContainer.onmousedown = function (e) {
        e.preventDefault();
        start = { x: e.clientX - translateX, y: e.clientY - translateY };
        panning = true;
        zoomPanContainer.style.cursor = 'grabbing';
    };

    zoomPanContainer.onmouseup = function () {
        panning = false;
        zoomPanContainer.style.cursor = 'grab';
    };

    zoomPanContainer.onmouseleave = function () { // Stop panning if mouse leaves container
        panning = false;
        zoomPanContainer.style.cursor = 'grab';
    };

    zoomPanContainer.onmousemove = function (e) {
        e.preventDefault();
        if (!panning) {
            return;
        }
        translateX = e.clientX - start.x;
        translateY = e.clientY - start.y;
        setTransform();
    };

    zoomPanContainer.onwheel = function (e) {
        e.preventDefault();
        const xs = (e.clientX - translateX) / scale;
        const ys = (e.clientY - translateY) / scale;
        const delta = (e.wheelDelta ? e.wheelDelta : -e.deltaY);

        (delta > 0) ? (scale *= 1.1) : (scale /= 1.1);
        scale = Math.min(Math.max(0.2, scale), 4); // Min 0.2x, Max 4x zoom

        translateX = e.clientX - xs * scale;
        translateY = e.clientY - ys * scale;

        setTransform();
    };

    // 添加视图选项的点击事件
    const viewOptions = document.querySelectorAll('.view-option');
    viewOptions.forEach(option => {
        option.addEventListener('click', function() {
            viewOptions.forEach(opt => opt.classList.remove('active'));
            this.classList.add('active');
        });
    });

    function renderGraph(nodes, parentElement) {
        const mainColumnsData = {
            "上游": [],
            "中游": [],
            "下游": []
        };

        // Group top-level nodes by their NodeNumDesc
        nodes.forEach(node => {
            if (node.NodeNumDesc && mainColumnsData[node.NodeNumDesc]) {
                mainColumnsData[node.NodeNumDesc].push(node);
            } else {
                // Fallback or error handling if NodeNumDesc is unexpected
                console.warn("Node with unexpected NodeNumDesc:", node.NodeNumDesc, node);
            }
        });
        
        const columnOrder = ["上游", "中游", "下游"];
        columnOrder.forEach((columnName, index) => {
            if (mainColumnsData[columnName].length > 0) {
                const columnDiv = createColumn(columnName);
                mainColumnsData[columnName].forEach(node => {
                    // NodeLevel 1 items are the main blocks within a column
                    const nodeElement = createNodeElement(node);
                    columnDiv.appendChild(nodeElement);
                    
                    // 在节点添加到DOM后设置列宽
                    if (node.NodeLevel === 1) {
                        const childCount = countAllDescendants(node);
                        const MAX_NODES_PER_COLUMN = 20;
                        const requiredColumns = distributeNodesPerColumn(childCount, MAX_NODES_PER_COLUMN);
                        const actualColumns = Math.min(requiredColumns, 4);
                        
                        // 现在节点已经添加到DOM，可以找到父元素
                        if (actualColumns > 3) {
                            columnDiv.classList.add('width-columns-4');
                        } else if (actualColumns > 2) {
                            columnDiv.classList.add('width-columns-3');
                        } else if (actualColumns > 1) {
                            columnDiv.classList.add('width-columns-2');
                        }
                    }
                });
                parentElement.appendChild(columnDiv);
            }
            // Add arrow if not the last column
            if (index < columnOrder.length - 1 && mainColumnsData[columnOrder[index+1]].length > 0) {
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                arrow.innerHTML = '→';
                parentElement.appendChild(arrow);
            }
        });
    }

    function createColumn(title) {
        const columnDiv = document.createElement('div');
        let columnClass = '';
        if (title === '上游') columnClass = 'upstream-column';
        else if (title === '中游') columnClass = 'midstream-column';
        else if (title === '下游') columnClass = 'downstream-column';
        
        columnDiv.className = `industry-column ${columnClass}`;

        const titleContainer = document.createElement('div');
        titleContainer.className = 'column-title-container';
        const titleEl = document.createElement('span');
        titleEl.className = 'column-title';
        titleEl.textContent = title;
        titleContainer.appendChild(titleEl);
        columnDiv.appendChild(titleContainer);
        
        return columnDiv;
    }

    function createNodeElement(nodeData) {
        const nodeElement = document.createElement('div');
        nodeElement.className = `node-level-${nodeData.NodeLevel}`;
        
        // 如果是顶级分类节点（上游/中游/下游），不显示文本
        if (nodeData.NodeNumDesc && ["上游", "中游", "下游"].includes(nodeData.NodeNumDesc)) {
            // 不设置文本内容
        } else {
            // 为非顶级节点创建标题元素
            const titleElement = document.createElement('div');
            titleElement.className = 'node-title';
            titleElement.textContent = nodeData.NodeName;
            nodeElement.appendChild(titleElement);
        }

        if (nodeData.Children && nodeData.Children.length > 0) {
            // 对于第一级节点，需要特殊处理列布局
            if (nodeData.NodeLevel === 1) {
                // 递归计算所有子孙节点的总数量
                const childCount = countAllDescendants(nodeData);
                
                // 计算需要的列数（每列最多20个节点）
                const MAX_NODES_PER_COLUMN = 20;
                const requiredColumns = distributeNodesPerColumn(childCount, MAX_NODES_PER_COLUMN);
                
                // 创建多列容器（外层容器）
                const columnsContainer = document.createElement('div');
                columnsContainer.className = 'multi-columns-wrapper';
                columnsContainer.style.display = 'flex';
                columnsContainer.style.gap = '15px';
                nodeElement.appendChild(columnsContainer);
                
                // 限制最多4列
                const actualColumns = Math.min(requiredColumns, 4);
                
                // 将子节点分组，每组不超过MAX_NODES_PER_COLUMN个节点
                const columns = [];
                for (let i = 0; i < actualColumns; i++) {
                    columns.push([]);
                }
                
                // 计算每个子节点及其子孙节点的数量，用于分配列
                let childrenWithCounts = nodeData.Children.map(child => {
                    const count = countAllDescendants(child) + 1; // +1 表示节点自身
                    return { node: child, count: count };
                });
                
                // 贪心算法，将节点分配到各列，尽量保持每列总节点数接近
                let columnCounts = new Array(actualColumns).fill(0);
                
                // 从大到小排序，优先分配大节点
                childrenWithCounts.sort((a, b) => b.count - a.count);
                
                // 分配节点到列
                childrenWithCounts.forEach(item => {
                    // 找出当前节点数最少的列
                    const minColumnIndex = columnCounts.indexOf(Math.min(...columnCounts));
                    columns[minColumnIndex].push(item.node);
                    columnCounts[minColumnIndex] += item.count;
                    console.log(`分配节点 ${item.node.NodeName}(${item.count}个) 到第${minColumnIndex+1}列，当前该列共${columnCounts[minColumnIndex]}个节点`);
                });
                
                // 为每列创建容器并添加节点
                for (let i = 0; i < actualColumns; i++) {
                    if (columns[i].length > 0) {
                        const columnDiv = document.createElement('div');
                        columnDiv.className = `node-level-${nodeData.NodeLevel}-column column-${i+1}`;
                        columnDiv.style.flexGrow = '1';
                        columnDiv.style.width = `${100/actualColumns}%`;
                        
                        // 为该列的每个子节点创建元素
                        columns[i].forEach(childNode => {
                            const childElement = createNodeElement(childNode);
                            columnDiv.appendChild(childElement);
                        });
                        
                        // 添加列到容器
                        columnsContainer.appendChild(columnDiv);
                    }
                }
                
                return nodeElement;
            } else {
                // 对于非第一级节点，使用原来的逻辑
                const childrenContainer = document.createElement('div');
                childrenContainer.className = `node-level-${nodeData.NodeLevel}-items-container`;
                
                nodeData.Children.forEach(childNode => {
                    const childElement = createNodeElement(childNode);
                    childrenContainer.appendChild(childElement);
                });
                nodeElement.appendChild(childrenContainer);
            }
        }
        return nodeElement;
    }
    
    // 递归计算节点及其所有子孙节点的总数量
    function countAllDescendants(node) {
        if (!node.Children || node.Children.length === 0) {
            return 0;
        }
        
        let count = node.Children.length; // 直接子节点数量
        
        // 递归计算每个子节点的子孙节点数量
        for (const child of node.Children) {
            count += countAllDescendants(child);
        }
        
        return count;
    }
    
    // 计算每列应包含的节点数并返回分配方案
    function distributeNodesPerColumn(totalNodes, maxNodesPerColumn) {
        const requiredColumns = Math.ceil(totalNodes / maxNodesPerColumn);
        console.log(`总节点数: ${totalNodes}, 每列最大节点数: ${maxNodesPerColumn}, 需要列数: ${requiredColumns}`);
        return requiredColumns;
    }
    
    // 添加全屏按钮功能
    document.querySelector('.graph-sidebar-item[title="全屏"]').addEventListener('click', function() {
        const chartSection = document.getElementById('industry-chain-section');
        if (!document.fullscreenElement) {
            if (chartSection.requestFullscreen) {
                chartSection.requestFullscreen();
            } else if (chartSection.webkitRequestFullscreen) { /* Safari */
                chartSection.webkitRequestFullscreen();
            } else if (chartSection.msRequestFullscreen) { /* IE11 */
                chartSection.msRequestFullscreen();
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
        }
    });
});
</script>
<!-- 引入侧边栏功能 -->
<script src="{% static 'data_hall/js/chain-sidebar.js' %}"></script>
{% endblock %}